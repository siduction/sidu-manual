<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="de" lang="de">
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="generator" content="pandoc">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>Secure Shell</title>
<style>
body            {font-family: Verdana, sans-serif; margin: 0 auto; float: none; max-width: 55em; padding: 4%; color: black;}
p, li           {line-height: 1.5;}
p img           {width: 1.5em; height: auto; border: 0.1em solid #CCC;}
p code, li code {display: inline; color: #000; padding: 0.1em; font-size: 1.2em;}
p.warning       {display: block; line-height: 1.3em; padding: 0.4em; background: #FFDDDD; border: 0.15em solid #C33; border-radius: 0.5em;}
p.warning code  {background: #FFDDDD; border: none;}
code            {display: block; max-width: 100%; background-color: #EEE; padding: 0.3em; border: #CCC thin solid; border-radius: 3px; font-size: 1.2em;}
pre             {color: #000; padding: 0.3em;}
pre code        {display: block; overflow:auto; max-width: 100%; color: #000; padding-bottom: 0.8em;}
li pre code     {padding: 0.3em 0.3em 0.8em 0.3em;}
table, th, td   {background-color: #EED; border: #CCC thin solid; border-collapse: collapse; padding: 0.15em;}
hr              {height: 0.2em; background-color: #CCC; border: 0; margin: 2em 0 2em 0;}
figcaption      {font-size: 0.8em; color: #888;}
figure img      {max-width: 85%; height: auto; border: 0.1em solid #CCC;}
a               {color: black; text-decoration: underline;}
a:visited       {color: #FF6600;}
a:hover         {color: #FFF; background-color: #FF6600; transition: all .25s ease-in;}
#rev            {float:right; font-size: 0.8em; color: #888;}
</style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Secure Shell</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#ssh" id="toc-ssh">SSH</a>
<ul>
<li><a href="#ssh-absichern" id="toc-ssh-absichern">SSH
absichern</a></li>
<li><a href="#ssh-f&uuml;r-x-window-programme"
id="toc-ssh-f&uuml;r-x-window-programme">SSH f&uuml;r X-Window Programme</a></li>
<li><a href="#kopieren-scp-via-ssh"
id="toc-kopieren-scp-via-ssh">Kopieren scp via ssh</a></li>
<li><a href="#ssh-mit-dolphin-oder-thunar"
id="toc-ssh-mit-dolphin-oder-thunar">SSH mit Dolphin oder
Thunar</a></li>
<li><a href="#sshfs---auf-einem-entfernten-computer-mounten"
id="toc-sshfs---auf-einem-entfernten-computer-mounten">SSHFS - auf einem
entfernten Computer mounten</a></li>
</ul></li>
</ul>
</nav>
<h2 id="ssh">SSH</h2>
<p class="warning">
<strong>SSH aktivieren</strong> <br />Bei siduction ist ssh sowohl auf
dem Live-ISO als auch nach der Installation nicht aktiviert! Um
<em>ssh</em> zu aktivieren und deaktivieren nutzen Sie bitte die Scripte
<code>sshactivate</code> und <code>sshdeactivate</code>. Sie befinden
sich in <code>/usr/sbin</code>. Alternativ nutzen sie die Starter im
Anwendungsmen&uuml; &gt; Internet/Netzwerk.
</p>
<p><strong>Definition von SSH aus <a
href="http://de.wikipedia.org/wiki/Secure_Shell">Wikipedia</a></strong>
:</p>
<p>Secure Shell oder SSH bezeichnet sowohl ein Netzwerkprotokoll als
auch entsprechende Programme, mit deren Hilfe man auf eine sichere Art
und Weise eine verschl&uuml;sselte Netzwerkverbindung mit einem entfernten
Ger&auml;t herstellen kann. H&auml;ufig wird diese Methode verwendet, um sich eine
entfernte Kommandozeile quasi auf den lokalen Rechner zu holen, das
hei&szlig;t, auf der lokalen Konsole werden die Ausgaben der entfernten
Konsole ausgegeben und die lokalen Tastatureingaben werden an den
entfernten Rechner gesendet. Hierdurch wird der Effekt erreicht, als
s&auml;&szlig;e man vor der entfernten Konsole, was beispielsweise sehr gut zur
Fernwartung eines in einem entfernten Rechenzentrum stehenden
Root-Servers genutzt werden kann. Die neuere Protokoll-Version SSH-2
bietet weitere Funktionen wie Daten&uuml;bertragung per SFTP.</p>
<p>Generell sollte SSH zur Remote Steuerung nur konfiguriert und
eingesetzt werden, wenn man sich sicher ist, welche Auswirkungen die
Einstellungen in der Datei <code>/etc/ssh/sshd_config</code> und ggf.
den Dateien im Verzeichnis <code>/etc/ssh/sshd_config.d/</code>
haben.<br />
Im Zweifel ist die Dokumentation in den Manpages
<strong><code>man sshd_config</code></strong>,
<strong><code>man ssh_config</code></strong> oder in Internet zu
studieren, oder der Rat fachkundiger Personen einzuholen.</p>
<h3 id="ssh-absichern">SSH absichern</h3>
<p>Es ist nicht sicher, Root-Anmeldungen via SSH zum Standard zu machen.
Debian sollte sicher sein, nicht unsicher. Ebenso sollen Angreifer nicht
die M&ouml;glichkeit haben, &uuml;ber einen l&auml;ngeren Zeitraum einen
wortlistenbasierten Passwort Angriff (brute force attack) auf den
SSH-Login durchzuf&uuml;hren. Deshalb nehmen wir einige &Auml;nderungen in der
Datei <code>/etc/ssh/sshd_config</code> vor.</p>
<p><strong>Folgende Einstellungen k&ouml;nnen zur Erh&ouml;hung der Sicherheit
angepasst werden:</strong><br />
(Um die Funktion der Eintr&auml;ge zu aktivieren muss das Kommentarzeichen
‘#’ entfernt werden.)</p>
<ul>
<li><p><strong>Port <gew&uuml;nschter Port></strong>:<br />
Dieser Eintrag muss auf den Port verweisen, der auf dem Router zur
Weiterleitung freigeschaltet ist. Die IANA hat dem Protokoll den
TCP-Port 22 zugeordnet und Debian setzt ihn als Standard. Es ist jedoch
ratsam einen Port au&szlig;erhalb des Standardscanbereichs zu verwenden. Wir
benutzen deswegen z.B. Port 5874 um Angriffe zu erschweren, da der
SSH-Port dem Angreifer nicht bekannt ist.</p>
<pre><code>Port 5874</code></pre></li>
<li><p><strong>ListenAddress
<IP des Rechners oder der Netzwerkschnittstelle></strong>:<br />
Da der Port vom Router weitergeleitet wird, muss der Rechner eine
statische IP-Adresse benutzen, sofern kein lokaler DNS-Server verwendet
wird. Aber wenn etwas so Kompliziertes wie SSH unter Benutzung eines
lokalen DNS-Servers aufgesetzt werden soll und diese Anweisungen
ben&ouml;tigt werden, kann sich leicht ein gravierender Fehler einschleichen.
Wir verwenden eine statische IP f&uuml;r das Beispiel:</p>
<pre><code>ListenAddress 192.168.2.134</code></pre>
<p>Das SSH Protokoll 2 mit seinen verbesserten und erweiterten
Funktionen ist bereits Grundeinstellung bei Debian.</p></li>
<li><p><strong>LoginGraceTime
<Zeitrahmen des Anmeldevorgangs></strong>:<br />
Die erlaubte Zeitspanne betr&auml;gt als Standard 2 Minuten. Da man f&uuml;r
gew&ouml;hnlich keine zwei Minuten ben&ouml;tigt, um Benutzernamen und Passwort
einzugeben, stellen wir eine etwas k&uuml;rzere Zeitspanne ein:</p>
<pre><code>LoginGraceTime 30</code></pre>
<p>Nun hat man 30 Sekunden Zeit zum Anmelden, und Hacker haben keine
zwei Minuten bei jedem Versuch, das Passwort zu knacken.</p></li>
<li><p><strong>PermitRootLogin &lt;prohibit‐password&gt;</strong>:<br />
Warum Debian hier Erlaubnis zur Anmeldung als Root erteilt, ist nicht
nachvollziehbar. Wir korrigieren zu <code>no</code>:</p>
<pre><code>PermitRootLogin no
StrictModes yes</code></pre>
<p>Alternativ kann man diese Option auf <em>forced‐commands‐only</em>
setzen. Damit wird die Anmeldung von root &uuml;ber asymmetrische
Authentifizierung erlaubt, aber nur falls die Option <em>command</em>
festgelegt wurde (was n&uuml;tzlich f&uuml;r die Durchf&uuml;hrung ferner
Sicherungskopien ist, selbst wenn die Anmeldung von root normalerweise
nicht erlaubt ist). Alle anderen Authentifizierungsmethoden f&uuml;r root
bleiben deaktiviert.</p></li>
<li><p><strong>MaxAuthTries
<Anzahl der erlaubten Anmeldungsversuche></strong>:<br />
Mehr als 3 oder 4 Versuche sollten nicht erm&ouml;glicht werden:</p>
<pre><code>MaxAuthTries 3</code></pre></li>
</ul>
<p><strong>Folgende Einstellungen m&uuml;ssen hinzugef&uuml;gt werden, so sie
nicht vorhanden sind:</strong></p>
<ul>
<li><p><strong>AllowUsers <xxx></strong>:<br />
Benutzernamen, welchen der Zugriff via SSH erlaubt ist, getrennt durch
Leerzeichen. Nur eingetragene Benutzer k&ouml;nnen den Zugang verwenden, und
dies nur mit Benutzerrechten. Mit <code>adduser</code> sollte man einen
User hinzuf&uuml;gen, der speziell zur Nutzung von SSH verwendet wird:</p>
<pre><code>AllowUsers werauchimmer1 werauchimmer2</code></pre></li>
<li><p><strong>PermitEmptyPasswords <xxx></strong>:<br />
dem Benutzer soll ein sch&ouml;nes langes Passwort gegeben werden, das man in
einer Million Jahren nicht erraten kann. Dieser Benutzer sollte der
einzige mit SSH Zugriff sein. Ist er einmal angemeldet, kann er mit
<code>su</code> Root werden:</p>
<pre><code>PermitEmptyPasswords no</code></pre></li>
<li><p><strong>PasswordAuthentication <xxx></strong>:<br />
nat&uuml;rlich muss hier ‘yes’ gesetzt werden. Es sei denn, man verwendet
einen KeyLogin.</p>
<pre><code>PasswordAuthentication yes</code></pre></li>
</ul>
<p>Schlussendlich:</p>
<pre><code>systemctl restart ssh</code></pre>
<p>Nun hat man eine etwas sicherere SSH-Konfiguration. Nicht vollkommen
sicher, nur besser, vor allem wenn man einen Benutzer hinzugef&uuml;gt hat,
der speziell zur Verwendung mit SSH dient.</p>
<h3 id="ssh-f&uuml;r-x-window-programme">SSH f&uuml;r X-Window Programme</h3>
<p>ssh -X erm&ouml;glicht die Verbindung zu einem entfernten Computer und die
Anzeige von dessen Grafikserver X auf dem eigenen lokalen Computer. Den
Befehl gibt man als Benutzer (nicht als Root) ein (und man beachte, dass
X ein Gro&szlig;buchstabe ist):</p>
<pre><code>$ ssh -X username@xxx.xxx.xxx.xxx (or IP)</code></pre>
<p>Man gibt das Passwort f&uuml;r den Benutzernamen des entfernten Computers
ein und startet eine graphische Anwendung in der Shell. Beispiele:</p>
<pre><code>$ iceweasel ODER libreoffice ODER kspread</code></pre>
<p>Bei sehr langsamen Verbindungen kann es von Vorteil sein, die
Komprimierungsoption zu nutzen, um die &Uuml;bertragungsrate zu erh&ouml;hen. Bei
schnellen Verbindungen kann es jedoch zum entgegengesetzten Effekt
kommen:</p>
<pre><code>$ ssh -C -X username@xxx.xxx.xxx.xxx (or IP)</code></pre>
<p>Weitere Informationen erh&auml;lt man mit
<strong><code>man ssh</code></strong></p>
<p><strong>Anmerkung:</strong><br />
Falls ssh eine Verbindung verweigert und man eine Fehlermeldung erh&auml;lt,
sucht man in $HOME nach dem versteckten Verzeichnis <code>.ssh</code> ,
l&ouml;scht die Datei <code>known_hosts</code> und versucht einen neuen
Verbindungsaufbau. Dieses Problem tritt haupts&auml;chlich auf, wenn man die
IP-Adresse dynamisch zugewiesen hat (DCHP).</p>
<h3 id="kopieren-scp-via-ssh">Kopieren scp via ssh</h3>
<p><strong>scp</strong> ist ein Befehlszeilenprogramm (Terminal/CLI), um
Dateien zwischen Netzwerkcomputern zu kopieren. Es verwendet ssh zur
Authentifizierung und zum sicheren Datentransfer, daher verlangt scp zur
Anmeldung ein Passwort bzw. eine Passphrase.</p>
<p>So man ssh-Rechte an einem Netzwerk-PC oder Netzwerk-Server besitzt,
erm&ouml;glicht scp das Kopieren von Partitionen, Verzeichnissen oder Dateien
zu oder von einem Netzwerkcomputer (bzw. zu einem Bereich auf selbigem),
f&uuml;r den man Zugangsrechte besitzt. Dies kann zum Beispiel ein PC oder
Server im lokalen Netzwerk sein oder aber auch ein Computer in einem
fremden Netzwerk oder ein lokales USB-Laufwerk. Der Kopiervorgang kann
zwischen entfernten Computern/Speicherger&auml;ten stattfinden.</p>
<p>Es k&ouml;nnen rekursiv auch ganze Partitionen bzw. Verzeichnisse mit dem
Befehl <code>scp -r</code> kopiert werden. Zu beachten ist, dass scp -r
auch symbolischen Links im Verzeichnisbaum folgt.</p>
<p><strong>Beispiele:</strong></p>
<ol type="1">
<li><p>Kopieren einer Partition:</p>
<pre><code>scp -r &lt;user&gt;@xxx.xxx.x.xxx:/media/disk1part6/ /media/diskXpartX/</code></pre></li>
<li><p>Kopieren eines Verzeichnisses auf einer Partition, in diesem Fall
eines Verzeichnisses mit der Bezeichnung “photos” im $HOME:</p>
<pre><code>scp -r &lt;user&gt;@xxx.xxx.x.xxx:~/photos/ /media/diskXpartX/xx</code></pre></li>
<li><p>Kopieren einer Datei in einem Verzeichnis einer Partition, in
diesem Fall eine Datei im $HOME:</p>
<pre><code>scp &lt;user&gt;@xxx.xxx.x.xxx:~/filename.txt /media/diskXpartX/xx</code></pre></li>
<li><p>Kopieren einer Datei auf einer Partition:</p>
<pre><code>scp &lt;user&gt;@xxx.xxx.x.xxx:/media/disk1part6/filename.txt /media/diskXpartX/xx</code></pre></li>
<li><p>Falls man sich im Laufwerk bzw. Verzeichnis befindet, in das ein
Verzeichnis bzw. eine Datei kopiert werden soll, verwendet man nur einen
<strong>.</strong> (Punkt):</p>
<pre><code>scp -r &lt;user&gt;@xxx.xxx.x.xxx:/media/disk1part6/filename.txt . </code></pre></li>
</ol>
<p>Weitere Informationen bietet die Manpage:</p>
<pre><code>man scp</code></pre>
<h3 id="ssh-mit-dolphin-oder-thunar">SSH mit Dolphin oder Thunar</h3>
<p>Dolphin und Thunar sind f&auml;hig, auf Daten eines entfernten Rechners
zuzugreifen, indem sie das <em>“sftp”</em> Protokoll benutzen, welches
in ssh vorhanden ist.</p>
<p>So wird es gemacht:</p>
<ol type="1">
<li><strong>F&uuml;r einen entfernten Server</strong><br />
Man &ouml;ffnet ein neues Dateimanager-Fenster oder einen neuen Reiter.<br />
Eingabe in die Adress-Leiste nach dem Muster:
<ul>
<li><code>sftp://username@ssh-server.com</code><br />
Dann &ouml;ffnet sich ein Dialog-Fenster und fragt nach dem SSH-Passwort. Man
gibt das Passwort ein und klickt auf OK,<br />
</li>
<li>oder die Eingabe enth&auml;lt bereits das Passwort:<br />
<code>sftp://username:password@remote_hostname_or_ip</code><br />
Es wird nicht nach einem Passwort gefragt, man wird direkt
verbunden.</li>
</ul></li>
<li><strong>F&uuml;r eine LAN-Umgebung</strong><br />
Nach dem gleichen Muster wie zuvor:
<ul>
<li><code>sftp://username@192.168.x.x</code><br />
mit Dialog-Fenster f&uuml;r das SSH-Passwort,<br />
</li>
<li>oder gleich mit Passwort:<br />
<code>sftp://username:passwort@192.168.x.x</code></li>
</ul></li>
</ol>
<p>Bitte richtige IP eingeben!<br />
Eine SSH-Verbindung ist nun hergestellt. In diesem Fenster kann man mit
den Dateien auf dem SSH-Server arbeiten, als w&auml;ren es lokale
Dateien.</p>
<p><strong>ANMERKUNG:</strong><br />
Wenn ein anderer Port als 22 (Grundeinstellung) benutzt wird, muss
dieser bei Verwendung von sftp angegeben werden. Die Eingabe folgt dann
der Syntax:<br />
<code>sftp://user@ip:port</code>,<br />
dies ist auch die Standardsyntax f&uuml;r viele Protokolle/Programme wie sftp
und smb.</p>
<h3 id="sshfs---auf-einem-entfernten-computer-mounten">SSHFS - auf einem
entfernten Computer mounten</h3>
<p>SSHFS ist eine einfache, schnelle und sichere Methode unter
Verwendung von FUSE, um ein entferntes Dateisystem einzubinden. Auf
Serverseite ben&ouml;tigt man ausschlie&szlig;lich einen laufenden ssh-daemon.</p>
<p>Auf Seite des Clients muss vermutlich sshfs erst installiert
werden:</p>
<pre><code>apt update &amp;&amp; apt install sshfs</code></pre>
<p><em>fuse3</em> und <em>groups</em> sind bereits auf dem ISO und
m&uuml;ssen nicht extra installiert werden.</p>
<p>Das Einbinden eines entfernten Dateisystems ist sehr einfach:</p>
<pre><code>sshfs  -o idmap=user username@entfernter_hostname:verzeichnis lokaler_mountpunkt</code></pre>
<p>Wenn kein bestimmtes Verzeichnis angegeben wird, wird das
Home-Verzeichnis des entfernten Nutzers eingebunden. Bitte beachten: der
Doppelpunkt “<strong><code>:</code></strong>” ist unbedingt
erforderlich, auch wenn kein Verzeichnis angegeben wird!</p>
<p>Nach erfolgter Einbindung verh&auml;lt sich das entfernte Verzeichnis wie
jedes andere lokale Dateisystem. Man kann wie auf einem lokalen
Dateisystem nach Dateien suchen, diese lesen und &auml;ndern sowie Skripte
ausf&uuml;hren.</p>
<p>Die Einbindung des entfernten Hosts wird mit folgendem Befehl
gel&ouml;st:</p>
<pre><code>fusermount -u lokaler_mountpunkt</code></pre>
<p>Bei regelm&auml;&szlig;iger Nutzung von sshfs empfiehlt sich ein Eintrag in der
Datei <code>/etc/fstab</code> (alles in einer Zeile):</p>
<pre><code>sshfs#remote_hostname://remote_directory /local_mount_
 point fuse -o idmap=user ,allow_other,uid=1000,gid=1000,
 noauto,fsname=sshfs#remote_hostname://remote_directory 0 0 </code></pre>
<p>Als n&auml;chstes muss das Kommentarzeichen vor
<em>“user_allow_other”</em> in der Datei <code>/etc/fuse.conf</code>
entfernt werden:</p>
<pre><code># Allow non-root users to specify the &#39;allow_other&#39;
# or &#39;allow_root&#39; mount options.
#
user_allow_other</code></pre>
<p>Dies erm&ouml;glicht jedem Nutzer der Gruppe fuse, das Dateisystem
einzubinden bzw. zu l&ouml;sen:</p>
<pre><code>mount /pfad/zum/mount/punkt # Einbindung
umount /pfad/zum/mount/punkt # L&ouml;sen</code></pre>
<p>Mit diesem Befehl pr&uuml;ft man, ob man Mitglied der Gruppe fuse ist:</p>
<pre><code>cat /etc/group | grep fuse</code></pre>
<p>Die Antwort sollte in etwa so aussehen:</p>
<pre><code>fuse:x:117: &lt;nutzername&gt;</code></pre>
<p>Falls der Nutzername (username) nicht gelistet ist, verwendet man als
root den Befehl adduser:</p>
<pre><code>adduser &lt;nutzername&gt; fuse</code></pre>
<p><strong>Zur Beachtung:</strong><br />
Der Benutzer wird erst nach einem neuerlichen Einloggen Mitglied der
Gruppe “fuse” sein.<br />
Jetzt sollte der gew&uuml;nschte Nutzername gelistet und folgender Befehl
ausf&uuml;hrbar sein:</p>
<pre><code>mount lokaler_mountpunkt
    und
umount lokaler_mountpunkt</code></pre>
<div id="rev">
Zuletzt bearbeitet: 2023-10-19
</div>
</body>
</html>
